# 目录
- [1.堆、栈、方法区概念](#1)
- [2.堆详解](#2)
- [3.栈详解](#3)
- [4.方法区详解](#4)



---
---
# <a id='1'>1.堆、栈、方法区概念</a>
1. 堆解决的是数据存储的问题，即数据怎么放，放在哪儿
2. 栈解决程序的运行问题，即程序如何执行，或者说如何处理数据(实例对象引用)
3. 方法区则是辅助堆栈的快永久区，解决堆栈信息的产生，是先决条件  
举例:  
``` java
    class User(){ 
      String id;
      String name;
      String age;
    }
    User user1 = new User();
    User user2 = new User();
```
## 堆:user1,user2，一块内存空间
## 方法区:User 类及其方法实例
## 栈:存放对象引用


---------
# <span id='2'>2.堆详解</span>
1. Java 堆是 Java 应用程序关系最密切的内存空间，几乎所有对象都放在其中，并且 Java 堆完全是自动化管理的，通过垃圾回收机制，垃圾对象会自动清理，不需要显式地释放。
2. 根据垃圾回收机制不同，Java 堆有可能拥有不同的结构。最为常见的就是将整个 Java 堆分为**新生代**和**老年代**。其中新生代存放新生的对象或者年龄不大的对象，        
老年代则存放老年对象。

---
- 新生代分为三个区:  
eden  S0  S1
- 老年代只有1个区:  
tenured

**新生代(New Generation)**:   
- 通常初次分配的对象都位于新生代中，该区域主要是存放内存
较小并且生命周期较短的对象，比如局部变量。  
- 新生代会频繁执行内存回收(GC)，回收采用“复制-清除”算法，将内存分为两块(图中的from 和 to)，运行时每次只使用其中的1块(图中的 from )，另1块备用(图中的 to )。  
- 当发生GC时，将当前使用的内存块中存活的对象拷贝到备用内存块中，然后清除当前使用内存块，最后，交换两块内存的角色。  

**老年代(Old Generation)**:   
- 在新生代的GC中“幸存”下来的对象，它们会被转移到老年代中。
老年代存放生命力周期较长，内存较大的对象。  
- 老年代通常比新生代要大很多。老年代的GC回收采用“标记-清除”算法，分成标记和清除两个阶段。  
- 在标记阶段会触发停顿(stop the world)，多线程并发的完成对垃圾对象的标记，降低标记阶段耗时。在清理阶段，由GC线程负责清理回收对象，和应用线程同时执行，不影响应用运行。  
- 绝大多数情况下，对象首先分配在 eden区，在1次新生代回收后，如果对象还存活，则会进入S0或者S1区，之后每经过1次新生代回收，如果对象存活则它的年龄就加1。
- 当对象达到1定的年龄后，则进入老年代。
---

 3. 垃圾回收:
- 复制算法:
其核心思想就是将内存空间分为两块，每次只使用其中1块，在垃圾回收时，将正在使用的内存中的存留对象复制到未被使用的内存块中去，之后去清除之前正在使用的内存块中所有的对象，反复去交换两个内存的角色，完成垃圾收集。

*S0、S1*两个区块大小相等，可以互相转换角色。例如:  
`S0(user1、user2)`   
检测时，发现 user1 不用了，user2 引用还需要，则将 user2 复制到S1，再将S0整个清空  
`S0(user1、user2)--user1-->S1(user1)`  
结果:  
`S0()  S1(user1)`

S0 与 S1 也称from区和to区

**实例:**  
```
最大内存:981M
空闲内存:940M
总内存:981M
Heap
 PSYoungGen      total 305664K, used 47190K [0x00000000eab00000, 0x0000000100000000, 0x0000000100000000)
  eden space 262144K, 18% used [0x00000000eab00000,0x00000000ed915988,0x00000000fab00000)
  from space 43520K, 0% used [0x00000000fd580000,0x00000000fd580000,0x0000000100000000)
  to   space 43520K, 0% used [0x00000000fab00000,0x00000000fab00000,0x00000000fd580000)
 ParOldGen       total 699392K, used 0K [0x00000000c0000000, 0x00000000eab00000, 0x00000000eab00000)
  object space 699392K, 0% used [0x00000000c0000000,0x00000000c0000000,0x00000000eab00000)
 Metaspace       used 7919K, capacity 8218K, committed 8448K, reserved 1056768K
  class space    used 924K, capacity 987K, committed 1024K, reserved 1048576K
```
----
# <span id='3'>3.栈详解</span>
1. Java 栈是1块线程私有的内存空间，一个栈，一般由三部分组成:局部变量表，操作数栈和帧数据区。  

- 局部变量表:
用于报错函数的参数及局部变量
- 操作数栈:
主要保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。
- 帧数据区:
除了局部变量表和操作数栈以外，栈还需要1些数据来支持常量池的解析，这里帧数据区保存着访问常量池的指针，方便程序访问常量池。另外，当函数返回或者出现异常时，虚拟机必须有1个异常处理表，方便发送异常的时候找到异常的代码，因此异常处理表也是帧数据区的1部分。


-------------
# <span id='4'>4.方法区详解</span>
- Java 方法区和堆1样，方法区是1块所有线程共享的内存区域，它保存系统的类信息，比如类的字段、方法、常量池等。方法区的大小决定了系统可以保存多少个类，如果系统定义太多的类，导致方法区溢出。虚拟机同样会抛出内存溢出错误。方法区可以理解为永久区。