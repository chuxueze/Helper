# 目录
- [1.概念](#1)
- [2.算法](#2)

---------------------------------
# <span id='1'>1.概念</span>
垃圾回收(Garbage Collection,简称GC)

GC中的垃圾，特指存于内存中，不会再被使用的对象。

-----------------
# <span id='2'>2.算法</span>
引用计数法、标记压缩法、复制算法、分代、分区  
1. 引用计数法:  
这是个比较古老而经典的垃圾收集算法，其核心就是在对象被其他所引用时计数器加1，而当引用失效时减1。  
但是这种方式有非常严重的问题:无法处理循环引用的情况，还有就是每次进行加减操作浪费系统性能。
2. 标记清除法:  
就是分为标记和清除两个阶段进行处理内存中的对象，当然这种方式也有非常大的弊端，就是空间碎片问题，垃圾回收后的空间不是连续的，不连续的内存空间的工作效率要低于连续的内存空间。
3. 复制算法:  
其核心思想就是将内存空间分为两块，每次只使用其中一块，在垃圾回收时，将正在使用的内在中的存留对象
复制到未被使用的内存块中去，之后去清除之前正在使用的内存块中所有的对象，反复去交换这两个内存的角色，
完成垃圾收集。**Java中新生代的 from 和 to 空间就是使用这个算法。**
4. 标记压缩法:  
标记压缩法在标记清除法基础上做了优化，把存活的对象压缩到内存一端，而后进行垃圾清理。**Java中老年代
使用的就是标记压缩法**
5. 分代算法:
根据对象的特点把内存分成N块，而后根据每个内存的特点使用不同的算法。  
对于新生代和老年代来说，新生代回收频率高，但是每次回收耗时都很短，而老年代回收频率较低，但是耗时会较长，所以应该尽量减少老年代的GC。
6. 分区算法:
其主要就是将整个内存分为N多个小的独立空间，每个小空间都可以独立使用，这样细粒度的控制一次回收多少个小空间和哪些个小空间，而不是对整个空间进行GC，从而提升性能，并减少BC的停顿时间。

### 垃圾回收器的任务是识别和回收垃圾对象进行内存清理，为了让垃圾回收器可以高效地执行，大部分情况下，会要求系统进入一个停顿的状态。  
### 停顿的目的是终止所有应用线程，只有这样系统才不会有新的垃圾产生，同时停顿保证了系统状态在某一个瞬间的一致性，也有益于更好地标记垃圾对象。因此在垃圾回收时，都会有产生应用程序的停顿。