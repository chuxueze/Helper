    为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀。
我们上面也讲到了，Hash 值的范围值-2147483648 到 2147483648，前后加起来大概40亿的映射空间，
只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。但问题是1个40亿长度的数组，内存是放不下的。
所以这个散列值是不能直接拿来用的。用之前还要先做对数组的长度取模运算，得到的余数才能用来要存放的位置也就是对应的数组下标。
这个数组下标的计算方法是“ (n - 1) & hash ”。（n 代表数组长度）。




---------------------------------------------------------------------
    这个算法应该如何设计呢？

    我们首先可能会想到采用%取余的操作来实现。
但是，重点来了：“取余 (%) 操作中如果除数是 2 的幂次则等价于与其除数减 1 的与 (&)操作
（也就是说 hash%length==hash&(length-1)的前提是 length 是2的 n 次方；）。” 
并且采用二进制位操作 &，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是2的幂次方。