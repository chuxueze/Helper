1.线程是否安全:
2.效率:
3.对 Null key 和 Null value 的支持:
4.初始容量大小和每次扩充容量大小的不同:
5.底层数据结构:
6.HasMap 中带有初始容量的构造函数:
7.下面这个方法保证了 HashMap 总是使用2的幂作为哈希表的大小:



--------------------------------------------------------------------------------------------------------------------------------------
1.线程是否安全:

    HashMap 是非线程安全的，HashTable 是线程安全的；HashTable 内部的方法基本都经过 synchronized 修饰。
（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）；

---------------------------------------------------------------------------
2.效率:
    
    因为线程安全的问题，HashMap 要比 HashTable 效率高1点。另外，HashTable 基本被淘汰，不要在代码中使用它；

---------------------------------------------------------------------------
3.对 Null key 和 Null value 的支持:

    HashMap 中，null 可以作为键，这样的键只有1个，可以有1个或多个键所对应的值为 null。
但是在 HashTable 中 put 进的键值只要有1个 null，直接抛出 NullPointerException。

---------------------------------------------------------------------------
4.初始容量大小和每次扩充容量大小的不同:
    
    1)创建时如果不指定容量初始值，Hashtable 默认的初始大小为11，之后每次扩充，容量变为原来的 2n+1。
HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。
    2)创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，
而 HashMap 会将其扩充为2的幂次方大小（HashMap 中的tableSizeFor()方法保证，下面给出了源代码）。
也就是说 HashMap 总是使用2的幂作为哈希表的大小,后面会介绍到为什么是2的幂次方。

---------------------------------------------------------------------------
5.底层数据结构:
    
    JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。
Hashtable 没有这样的机制。

---------------------------------------------------------------------------
6.HasMap 中带有初始容量的构造函数:

    public HashMap(int initialCapacity, float loadFactor) {
        if (initialCapacity < 0)
            throw new IllegalArgumentException("Illegal initial capacity: " +
                                               initialCapacity);
        if (initialCapacity > MAXIMUM_CAPACITY)
            initialCapacity = MAXIMUM_CAPACITY;
        if (loadFactor <= 0 || Float.isNaN(loadFactor))
            throw new IllegalArgumentException("Illegal load factor: " +
                                               loadFactor);
        this.loadFactor = loadFactor;
        this.threshold = tableSizeFor(initialCapacity);
    }
     
     
    public HashMap(int initialCapacity) {
        this(initialCapacity, DEFAULT_LOAD_FACTOR);
    }


---------------------------------------------------------------------------
7.下面这个方法保证了 HashMap 总是使用2的幂作为哈希表的大小:
	/**
     * Returns a power of two size for the given target capacity.
     */
    static final int tableSizeFor(int cap) {
        int n = cap - 1;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
    }