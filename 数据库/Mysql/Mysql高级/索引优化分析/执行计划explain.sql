1.Explain:查询执行计划
2.执行计划包含的信息





覆盖索引:
要查找的值刚好是索引列

---------------------------
1.Explain:执行计划
  使用Explain关键字可以模拟优化器执行SQL查询语句，从而知道MySQL是如何处理你的SQL语句的。
分析你的查询语句或是表结构的性能瓶颈。
  语句：
  explain + sql语句
  如：
  explain select * from user;
  执行计划包含的信息
  作用：
    1.表的读取顺序
    2.数据读取操作的操作类型
    3.哪些索引可以使用
    4.哪些索引被实际使用
    5.表之间的引用
    6.每张表有多少行被优化器查询


-----------------------------
2.执行计划包含的信息
id  select_type  table  type  possible_keys  key  key_len  ref  rows Extra

字段解释
------------
id: select 查询的序列号，包含一组数字，表示查询中执行 select 子句或操作（加载）表的顺序
	三种情况：
	  id相同，执行顺序由上而下
	  id不同，id越大优先级越高，越先执行
	  id相同又不同，id高的先执行，id相同的由上而下顺序执行

------------	
select_type:
	值：
	1.SIMPLE（简单查询）
	    简单的 select 查询，查询中不包含子查询或者 UNION
	2.PRIMARY（主要查询）
		查询中若包含任何复杂的子查询，最外层查询则被标记为 PRIMARY
	3.SUBQUERY（子查询）
		在 select 或 where 列表中包含子查询
	4.DERIVED（衍生，起源）
		在 from 列表中包含的子查询被标记为 DERIVED（衍生）
		MySQL会递归执行这些子查询，把结果放在临时（虚拟）表里
		<derived2>表示虚表
	5.UNION
		若第二个 select 出现在 UNION 之后，则被标记为 UNION，
		若 UNION 包含在 from 子句的子查询中，外层 select 将被标记为：DERIVED
	6.UNION RESULT
		从　UNION 表获取结果的 select
		如：<union1,3>表示：id=1 和 id=3 的查询拼接结果
------------
table:
	显示这一行的数据是关于哪张表的
------------
type:
	访问类型排列：
	从最好到最差依次是：
	system>const>eq_ref>ref>range>index>ALL
	一般来说，保证查询至少可以达到range级别，最好能达到ref级别。
	1.system
		表只有一行记录（等于系统表），这是const类型的特例，平时不会出现
	2.const（常量）
		表示通过索引一次就找到了，const用于比较 primary key 或者 unique 索引。因为只匹配一行数据，所以很快。
		如将主键置于 where 列表中，MySQL就能将该查询转换为一个常量
	3.eq_ref(唯一索引)
		唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描。
		（如：两表关联，索引字段作为条件，查询出一条数据，一个业务只对应一条明细）
		（单表查询，索引字段作为条件，只查询出一条数据）
	4.ref(非唯一性索引扫描)
		非唯一性索引扫描，返回匹配某个单独值的所有行。
		本质上也是一种索引访问，它返回所有匹配某个单独值的行。然而，它可能会找到多个符合条件的行，
		所以它应该属于查找和扫描的混合体。
		（如：两表关联，索引字段作为条件，查询出多条数据，一个业务对应多条明细）
		（单表查询，索引字段作为条件，可查询出多条数据）
	5.range(范围)
		只检索给定范围的行，使用一个索引来选择行。key列显示使用了哪个索引。
		一般就是在 where 语句中出现了 between in > < 等查询。
		这种范围扫描索引扫描比全表扫描好，因为它只需要开始于索引的某一点，而结束于另一点，
		不用扫描全部索引。
	6.index（索引全部扫描）
	    Full Index Scan, index与All区别为index类型只遍历索引树。这通常比ALL快，因为索引文件通常比数据文件小。
	    （也就是说，虽然all和Index都读全表，但index是从索引中读取的，而all是从硬盘中读取的）
	7.all(全表扫描)
		Full Table Scan，将遍历全表以找到匹配的行。
------------
possible_keys:（可能用到的索引）
	显示可能应用在这张表中的索引，一个或多个。
	查询涉及到的字段上若存在索引，则该索引将被列出，但不一定会被查询实际使用。
------------
key:（用到的索引）
	实际使用的索引。如果为 NULL,则没有使用索引。
	查询中若使用了覆盖索引，则该索引仅出现在key列表中。
------------
key_len:
	表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。在不损失精确性的情况下，长度越短越好。
	key_len显示的值为索引字段的最大可能长度，并非实际使用长度，
	即key_len是根据表定义计算而得，不是通过表内检索出来的。
------------
ref:
	显示索引的哪一列被使用了，如果可能的话，最好是一个常数。哪些列或常量被用于查找索引列上的值。
	where 后面添加的条件，如果为一个常量，则为 const
------------
rows:
	根据表统计信息及索引选用情况，大致估算出找到所需的记录所需要读取的行数。
------------
Extra:(额外的，扩展的。group by 和 order by 最好使用索引，如果是复合索引，则用复合索引，多个字段。也就是最好是按照索引的个数和顺序来。)

	包含不适合在其他列中显示但十分重要的额外信息
	1.Using filesort:（最好避免,文件排序）
	   说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行排序。
	   mysql中无法利用索引完成的排序操作称为“文件排序”;
	   （如查询中用到排序，则最好是按索引排序）
	2.Using temporary（最好避免，临时表）
	   使用了临时表保存中间结果，mysql在对查询结果排序时使用临时表。常见于排序 order by 和分组查询 group by。
	3.Using index（效率高）
		表示相应的 select 操作中使用了覆盖索引（Covering Index），避免访问了表的数据行，效率好！
		如果同时出现 using where,表明索引被用来执行索引键值的查找。
		如果没有同时出现using where，表明索引用来读取数据而非执行查找动作。
		覆盖索引:（）
		要查找的值刚好是索引列，个数与字段名部分满足或完全满足。
		select 的数据列只用从索引中就能获得，不必读取数据行，Mysql可以利用索引返回 select 列表中的字段，
		而不必根据索引再次读取数据文件，也就是说查询列 要被所建立的索引覆盖。
	4.Using where:表明使用了 where 过滤
	  using join buffer:使用了连接缓存(关联查询时用到缓存)
	  impossible where（不可能的条件）:
	  where 子句的值总是 false，不能用来获取数据。如 where username='zhc' and username='hjy'
	  select tables optimized away:
	  distinct:
	  优化distinct操作，在找到第一匹配的元组后，停止找同样值的动作。
