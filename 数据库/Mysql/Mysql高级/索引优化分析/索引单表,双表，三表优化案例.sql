1.索引单表优化案例
2.索引两表优化案例
3.索引三表优化案例

-----------------
1.索引单表优化案例
select id,author_id from article where 
	category_id=1 and comments>1
	order by views desc limit 1;
建立索引：
	idx_index_ccv;
	此索引是 category_id,comments,views三个字段的联合索引。

结果：出现using filesort，索引失效。
原因：comments>1是一个range查询，并且是复合索引中的第二个字段，
      在这里会影响后面views，所以此处会失效。
解决方案：
	删除索引，重新建立索引。
	idx_index_cv
	此索引是 category_id,views两个字段的联合索引。
	避开范围查询字段去建立索引，提高sql效率。

-----------------
2.索引两表优化案例
实践证明：
左连接：A left join B 的情况下：
	在B的关联字段建立索引，比在A表建立索引高效。
	这是由左连接的特性决定的。left join 条件用于确定如何从右搜索行，因为左边一定都有了。
总结：
	在那个需要查询的表加索引，更高效。
	也就是说在副表加索引，查询效率更高效。

右连接同理:

-----------------
3.索引三表优化案例
三表关联查询：
	A left join B on A.id=B.id left join C on A.id=C.id
最好的索引是建立在B表和C表，也就是在两个副表B和C中建立索引。
结论：
	不管关联多少张表，索引最好设置在需要经常查询的字段中。

-------------------
Join 语句的优化建议：
1.尽可能减少 Join 语句中的NestedLoop的循环总次数，“永远用小结果集驱动大的结果集”。
如：图书分类与图书。
	图书分类是小结果表，作为主表，因为需要全表查询。
	图书是大结果集，需要条件查询，使用到索引。
	用图书分类表驱动图书表，是合理的做法。
结论：少数据的一方，作为主表，就算是全表查询，也比较快。
	多数据的一方作为副表，数据多的时候，需要运用索引提高效率。
2.优先优化嵌套循环里的内层循环查询（子查询）
3.保证 join 语句中被驱动表上 join 条件字段已经被索引。关联
4.当无法保证被驱动表的 join 条件字段被索引且内存资源充足的前提下，
不要吝惜 JoinBuffer 的设置。（可以通过设置将其调大）